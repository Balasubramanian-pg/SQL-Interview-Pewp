---
Created:
Company:
  -
Difficulty:
Status:
Category:
Sub category:
Question Link:
---
Of course! This is a fascinating and rather complex query that uses a `LEFT JOIN` with a tricky `WHERE` clause to get its counts. It's a fantastic candidate for a detailed breakdown and for showcasing a more intuitive alternative.

Here is the complete analysis.

***

### 1. The Question

The business question being asked by this SQL query is:

**"What percentage of newly signed-up users make at least one purchase within their first week (7 days) of signing up?"**

---

### 2. Table Schema

The query joins two tables, `signups` and `user_purchases`. A plausible schema for these tables would be:

```sql
-- Table: signups
-- Stores a record for every user who signs up for the service.
CREATE TABLE signups (
    user_id     INT PRIMARY KEY,
    signup_date DATE NOT NULL
);

-- Table: user_purchases
-- Stores a record for every purchase made by a user.
CREATE TABLE user_purchases (
    purchase_id  INT PRIMARY KEY,
    user_id      INT NOT NULL,
    purchase_date DATE NOT NULL,
    product_id   INT,
    FOREIGN KEY (user_id) REFERENCES signups(user_id)
);
```

---

### 3. Structured SQL Query (Method 1: `LEFT JOIN` with a Complex `WHERE`)

This is your original query, which uses a clever but non-obvious `WHERE` clause to prepare the data for counting.

```sql
-- Step 1: Count the total number of signups and the number who purchased in the first week.
WITH user_count_tbl AS (
    SELECT
        COUNT(DISTINCT up.user_id) AS total_purchase_users,
        COUNT(DISTINCT s.user_id) AS total_signup_users
    FROM
        signups AS s
    LEFT OUTER JOIN
        user_purchases AS up ON s.user_id = up.user_id
    WHERE
        up.purchase_date IS NULL
        OR (up.purchase_date BETWEEN s.signup_date AND (s.signup_date + INTERVAL '7 day'))
)
-- Step 2: Calculate the final percentage.
SELECT
    ROUND(
        100.0 * (total_purchase_users / total_signup_users),
        2
    ) AS single_purchase_pct
FROM
    user_count_tbl;
```
*Note: I've updated the percentage calculation to use `100.0` for more portable floating-point division.*

---

### 4. Explanation of the Query

This query uses a two-step process with a CTE to calculate the final percentage. The logic within the CTE is the most complex part.

**Step 1: The `user_count_tbl` CTE**

1.  **`FROM signups AS s LEFT OUTER JOIN user_purchases AS up ...`**: This is the foundation. A `LEFT JOIN` from `signups` to `user_purchases` ensures that **every single user who signed up** is included in the initial result set. If a user never made a purchase, the columns from the `up` table (like `up.user_id` and `up.purchase_date`) will be `NULL`.
2.  **The `WHERE` Clause**: This is the trickiest part. It filters the joined rows, keeping only two types of records:
    *   `up.purchase_date IS NULL`: This keeps all the records for users who signed up but **never made any purchases**.
    *   `OR (up.purchase_date BETWEEN ...)`: This keeps records for purchases that occurred **within the first 7 days** of the user's signup date.
    *   Crucially, this `WHERE` clause *filters out* any purchases that happened *after* the 7-day window.
3.  **The `COUNT` Functions**: These operate on the rows that remain after the `WHERE` filter.
    *   `COUNT(DISTINCT s.user_id) AS total_signup_users`: This counts the unique users from the `signups` table (`s`). Since the `WHERE` clause keeps all non-purchasers and all first-week purchasers, and we started with all signups, this correctly counts **all signed-up users**. This is our denominator.
    *   `COUNT(DISTINCT up.user_id) AS total_purchase_users`: This counts the unique users from the `user_purchases` table (`up`). The `COUNT()` function ignores `NULL` values. The `up.user_id` is only non-`NULL` for users who actually made a purchase that was kept by the `WHERE` clause. Therefore, this only counts users who made a purchase **within the first week**. This is our numerator.

**Step 2: The Final `SELECT` Statement**
*   This part is straightforward. It takes the two counts generated by the CTE and calculates the percentage, rounding it to two decimal places.

---

### 5. Another SQL Method (Method 2: Conditional Aggregation)

A more common and often more intuitive way to solve this is to use conditional aggregation, which avoids the complex `WHERE` clause.

```sql
WITH user_purchase_status AS (
    -- For each user, determine if they made a purchase in their first week.
    SELECT
        s.user_id,
        MAX(
            CASE
                WHEN up.purchase_date <= s.signup_date + INTERVAL '7 day' THEN 1
                ELSE 0
            END
        ) AS made_first_week_purchase
    FROM
        signups AS s
    LEFT JOIN
        user_purchases AS up ON s.user_id = up.user_id
    GROUP BY
        s.user_id
)
-- Calculate the average of the 0/1 flag to get the percentage.
SELECT
    ROUND(100.0 * AVG(made_first_week_purchase), 2) AS single_purchase_pct
FROM
    user_purchase_status;
```

---

### 6. Explanation of the Alternative Query

This method first creates a "status flag" for each user and then calculates the average of that flag to get the percentage.

**Step 1: The `user_purchase_status` CTE**

1.  **`FROM ... LEFT JOIN ...`**: It uses the same `LEFT JOIN` to connect all signups with their potential purchases.
2.  **`GROUP BY s.user_id`**: This is a key difference. It creates a summary group for **every single user who signed up**.
3.  **`MAX(CASE ... END) AS made_first_week_purchase`**: This is a conditional aggregation that creates a flag for each user.
    *   The `CASE` statement checks each purchase. If it occurred within the first 7 days, it returns `1`; otherwise, it returns `0`. (If a user never purchased, `up.purchase_date` is `NULL`, so the `ELSE 0` applies).
    *   The `MAX()` function then takes all the 0s and 1s for a single user. If that user had *any* purchase that resulted in a `1`, the `MAX` for that user will be `1`. Otherwise, it will be `0`.
    *   The result is a simple table with one row per `user_id` and a `made_first_week_purchase` flag of either `1` or `0`.

**Step 2: The Final `SELECT` Statement**
*   **`AVG(made_first_week_purchase)`**: This uses a powerful trick. The average of a column containing only 1s and 0s is mathematically equivalent to the percentage of 1s in that column. For example, `AVG(1, 1, 0, 0)` is `2/4 = 0.5`.
*   This elegantly calculates the ratio of users who purchased in the first week. We then multiply by `100.0` and `ROUND` to get the final percentage.