---
Company:
  - Facebook
Difficulty: Intermediate
Created:
Status:
Category:
Sub category:
Question Link:
---
### 1. The Question

The business or data question being answered by this query is:

**"Which pages on our platform have never received a single like? Provide a list of their page IDs."**

---

### 2. Table Schema

The query references two tables, `pages` and `page_likes`, which are linked by `page_id`. A logical schema for these tables would be:

```sql
-- Table: pages
-- Stores a record for every page that exists on the platform.
CREATE TABLE pages (
    page_id   INT PRIMARY KEY,
    page_name VARCHAR(255) NOT NULL,
    category  VARCHAR(100),
    date_created TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Table: page_likes
-- Stores a record each time a user likes a page.
-- A composite primary key ensures a user can only like a page once.
CREATE TABLE page_likes (
    like_id    INT PRIMARY KEY AUTO_INCREMENT, -- A unique ID for the like event
    page_id    INT NOT NULL,
    user_id    INT NOT NULL,
    liked_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (page_id) REFERENCES pages(page_id)
    -- We can assume a 'users' table exists where user_id is a foreign key.
);
```

---

### 3. Structured SQL Query (Method 1: `LEFT JOIN` with `IS NULL` Check)

This is your original query, perfectly formatted. This is a very common and efficient way to solve this problem.

```sql
SELECT
    p.page_id
FROM
    pages AS p
LEFT JOIN
    page_likes AS pl ON p.page_id = pl.page_id
WHERE
    pl.page_id IS NULL;
```

---

### 4. Explanation of the Query

This query cleverly uses a `LEFT JOIN` to find records in one table that have no corresponding match in another.

1.  **`FROM pages AS p LEFT JOIN page_likes AS pl ON p.page_id = pl.page_id`**
    *   This is the core of the query. A `LEFT JOIN` starts with the left table (`pages`) and includes **every single row** from it, regardless of whether it has a match in the right table (`page_likes`).
    *   It then tries to match each row from `pages` with rows in `page_likes` based on the condition `p.page_id = pl.page_id`.
    *   **The Key Behavior:**
        *   If a page from the `pages` table *has* likes, the join will create one or more rows with the page's data and the corresponding like data.
        *   If a page from the `pages` table has **no likes**, a row is still created for that page, but all the columns from the `page_likes` table (`pl.like_id`, `pl.page_id`, `pl.user_id`, etc.) will be filled with `NULL`.

2.  **`WHERE pl.page_id IS NULL`**
    *   This `WHERE` clause filters the result of the join. It specifically looks for those rows where the `page_id` column *from the `page_likes` table (`pl`)* is `NULL`.
    *   As explained above, this condition is only true for pages that had no matching entry in the `page_likes` table. This effectively isolates only the pages with no likes.

3.  **`SELECT p.page_id`**
    *   Finally, from these filtered rows (which represent the unliked pages), it selects and returns the `page_id`.

---

### 5. Another SQL Method (Method 2: Using a Subquery with `NOT IN`)

An alternative and often more intuitive way to write this query is by using a subquery.

```sql
SELECT
    page_id
FROM
    pages
WHERE
    page_id NOT IN (
        SELECT DISTINCT page_id
        FROM page_likes
    );
```

---

### 6. Explanation of the Alternative Query

This method achieves the same goal by breaking the problem into two distinct logical parts.

1.  **The Subquery: `(SELECT DISTINCT page_id FROM page_likes)`**
    *   The database executes this inner query first.
    *   It scans the `page_likes` table and creates a complete and unique list of all `page_id`s that appear in it. In other words, this creates a list of every page that has received at least one like.
    *   Using `DISTINCT` is a good practice for performance, though not strictly necessary for correctness with `NOT IN`.

2.  **The Outer Query: `SELECT page_id FROM pages WHERE page_id NOT IN (...)`**
    *   This query then runs on the `pages` table.
    *   For every `page_id` in the `pages` table, the `WHERE` clause checks if that ID is present in the list generated by the subquery.
    *   The **`NOT IN`** operator returns `TRUE` only for `page_id`s that are *not found* in the subquery's list.
    *   This effectively filters the `pages` table down to only those pages whose IDs were not in the "liked pages" list.

This approach is very readable as it closely matches the English logic: "Select pages where the ID is not in the list of liked pages." However, for very large tables, the `LEFT JOIN` method is often more performant than `NOT IN`.