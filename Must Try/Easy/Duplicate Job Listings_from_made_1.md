---
Created:
Company:
  -
Difficulty:
Status:
Category:
Sub category:
Question Link:
---
Of course! This is an excellent query that uses a Common Table Expression (CTE) to perform a two-step analysis: first identifying duplicates, and then counting the companies responsible for them.

Here is the complete breakdown.

***

### 1. The Question

The business question being asked by this SQL query is:

**"How many distinct companies have posted at least one job listing that is an exact duplicate of another? A duplicate is defined as a listing with the same company ID, title, and description."**

---

### 2. Table Schema

The query references a single table, `job_listings`. A plausible schema for this table would be:

```sql
-- Table: job_listings
-- Stores a record for every individual job posting on a platform.
CREATE TABLE job_listings (
    job_id       INT PRIMARY KEY,        -- Unique identifier for each job post
    company_id   INT NOT NULL,           -- The ID of the company that posted the job
    title        VARCHAR(255) NOT NULL,  -- The job title
    description  TEXT,                   -- The full text description of the job
    post_date    DATE                    -- The date the job was listed
);

-- A composite index on the grouping columns would significantly speed up this query.
CREATE INDEX idx_listings_group ON job_listings (company_id, title, description);
```

---

### 3. Structured SQL Query (Method 1: Using a Common Table Expression - CTE)

This is your original query, which is a very clear and readable way to solve this problem.

```sql
-- Step 1: Find all groups of listings that are exact duplicates.
WITH duplicated_listings AS (
    SELECT
        company_id,
        title,
        description
        -- We don't actually need the COUNT in the CTE's SELECT for the final query
        -- but it's useful for understanding the intermediate step.
    FROM
        job_listings
    GROUP BY
        company_id,
        title,
        description
    HAVING
        COUNT(job_id) > 1
)
-- Step 2: Count the unique companies from the list of duplicates.
SELECT
    COUNT(DISTINCT company_id) AS duplicate_companies
FROM
    duplicated_listings;
```

---

### 4. Explanation of the Query

This query elegantly breaks the problem into two logical parts using a CTE.

**Step 1: The `duplicated_listings` CTE**

1.  **`FROM job_listings`**: The query starts by reading from the `job_listings` table.
2.  **`GROUP BY company_id, title, description`**: This is the core of the duplicate detection logic. It groups rows together that have the exact same values for `company_id`, `title`, and `description`.
3.  **`HAVING COUNT(job_id) > 1`**: After grouping, the `HAVING` clause filters these groups. It keeps only the groups where the count of jobs is greater than one. This means any group that passes this filter represents a job that was posted multiple times with identical details.
4.  **Result of CTE**: The `duplicated_listings` CTE becomes a temporary table containing one row for each *group* of duplicate job posts. Each row includes the `company_id` of the company that posted the duplicates.

**Step 2: The Final `SELECT` Statement**

1.  **`FROM duplicated_listings`**: The final query operates on the temporary result set generated by the CTE.
2.  **`SELECT COUNT(DISTINCT company_id) AS duplicate_companies`**:
    *   This is the final aggregation. It looks at the `company_id` column in the `duplicated_listings` table.
    *   `COUNT(DISTINCT ...)` counts the number of *unique* company IDs. This is important: if a single company has three different sets of duplicate listings, it will still only be counted once in the final result.
    *   The result is a single number representing the total count of companies with duplicate posts.

---

### 5. Another SQL Method (Method 2: Using a Derived Table / Subquery in `FROM`)

You can achieve the exact same result without a CTE by using a subquery directly in the `FROM` clause. This is often called a "derived table."

```sql
SELECT
    COUNT(DISTINCT company_id) AS duplicate_companies
FROM (
    -- This inner query is the same as the one inside the CTE
    SELECT
        company_id,
        title,
        description
    FROM
        job_listings
    GROUP BY
        company_id,
        title,
        description
    HAVING
        COUNT(job_id) > 1
) AS duplicate_groups;
```

---

### 6. Explanation of the Alternative Query

This method is syntactically different but functionally identical for this use case.

1.  **The Inner Query (Derived Table)**:
    *   The query inside the parentheses is executed first. It's the exact same query we used inside the CTE: it finds all groups of duplicate job listings by grouping on `company_id`, `title`, and `description`, and then filtering with `HAVING COUNT(job_id) > 1`.
    *   The result of this inner query is a temporary result set that is given the alias `duplicate_groups`.

2.  **The Outer Query**:
    *   The outer `SELECT` statement then runs on this `duplicate_groups` derived table as if it were a real table.
    *   `SELECT COUNT(DISTINCT company_id) ...`: It performs the same final aggregation, counting the unique company IDs present in the result set from the inner query.

**Comparison:**
*   **CTE (Method 1):** Generally preferred for readability, especially when the logic is complex or when you need to reference the temporary result set multiple times in the main query.
*   **Derived Table (Method 2):** Can be more compact for simpler, single-use subqueries. In this case, the performance is likely identical to the CTE approach.