---
Company:
  - Google
Difficulty: Intermediate
Created:
Status:
Category:
Sub category:
Question Link:
---

### Question:

**Calculate the Return on Ad Spend (ROAS) for each advertiser using the `ad_campaigns` table. The ROAS should be calculated as the sum of revenue divided by the sum of spend for each advertiser. Round the ROAS to two decimal places and order the results by `advertiser_id`.**

### Table Schema:

Here is the schema for the `ad_campaigns` table in Markdown format:

| Column Name   | Data Type     | Description                                                 |
| ------------- | ------------- | ----------------------------------------------------------- |
| campaign_id   | INTEGER       | Unique identifier for each ad campaign.                     |
| advertiser_id | INTEGER       | Identifier for the advertiser running the campaign.         |
| spend         | DECIMAL(10,2) | Amount spent on the campaign.                               |
| revenue       | DECIMAL(10,2) | Revenue generated from the campaign.                        |
| ...           | ...           | Additional columns as needed for other campaign attributes. |

### Solution:

 ```sql
 -- Calculate ROAS for each advertiser
SELECT
    advertiser_id,
    ROUND(SUM(revenue) / SUM(spend), 2) AS ROAS
FROM
    ad_campaigns
GROUP BY
    advertiser_id
ORDER BY
    advertiser_id;
```

### Explanation:

1. **SELECT Clause**:
    
    - `advertiser_id`: This column is selected to identify each advertiser.
    - `ROUND(SUM(revenue) / SUM(spend), 2) AS ROAS`: This calculates the ROAS for each advertiser. The `SUM(revenue)` gives the total revenue generated by all campaigns of the advertiser, and `SUM(spend)` gives the total amount spent. The division of these sums gives the ROAS, which is then rounded to two decimal places using the `ROUND` function.
2. **FROM Clause**:
    
    - Specifies the table `ad_campaigns` from which to retrieve the data.
3. **GROUP BY Clause**:
    
    - Groups the results by `advertiser_id` so that the sums of revenue and spend are calculated for each advertiser individually.
4. **ORDER BY Clause**:
    
    - Orders the results by `advertiser_id` in ascending order to present the results in a structured manner.

This query effectively calculates the ROAS for each advertiser by summing up their respective revenues and spends, then dividing these sums and rounding the result to two decimal places. The results are then ordered by `advertiser_id` for clarity.

Certainly! Another method to calculate the Return on Ad Spend (ROAS) for each advertiser is to use a Common Table Expression (CTE) to first aggregate the total revenue and spend for each advertiser, and then calculate the ROAS in the main query. This approach can make the query more readable and modular.

Here's how you can do it:

```sql
WITH advertiser_totals AS (
    -- Calculate total revenue and spend for each advertiser
    SELECT
        advertiser_id,
        SUM(revenue) AS total_revenue,
        SUM(spend) AS total_spend
    FROM
        ad_campaigns
    GROUP BY
        advertiser_id
)

-- Calculate ROAS using the aggregated totals
SELECT
    advertiser_id,
    ROUND(total_revenue / total_spend, 2) AS ROAS
FROM
    advertiser_totals
ORDER BY
    advertiser_id;

```
### Explanation:

1. **CTE (`advertiser_totals`)**:
    
    - This CTE calculates the total revenue and total spend for each advertiser.
    - `SUM(revenue) AS total_revenue`: Sums up the revenue for each advertiser.
    - `SUM(spend) AS total_spend`: Sums up the spend for each advertiser.
    - The results are grouped by `advertiser_id` to ensure the sums are calculated per advertiser.
2. **Main Query**:
    
    - This query selects the `advertiser_id` and calculates the ROAS by dividing `total_revenue` by `total_spend`.
    - `ROUND(total_revenue / total_spend, 2) AS ROAS`: This rounds the ROAS to two decimal places.
    - The results are ordered by `advertiser_id` to present them in a structured manner.

This method separates the aggregation logic into a CTE, making the main query cleaner and easier to understand. It also allows for better modularity if additional calculations or transformations are needed in the future.
