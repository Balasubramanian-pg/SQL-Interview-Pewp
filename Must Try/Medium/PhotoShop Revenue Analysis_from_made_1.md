---
Company:
  - Adobe
Difficulty: Intermediate
Created:
Status:
Category:
Sub category:
Question Link:
---
Of course! This is an excellent query that uses a subquery to filter a main query, a very common and important SQL pattern.

Here is the complete breakdown.

***

### 1. The Question

The business question being asked by this SQL query is:

**"For customers who have purchased Photoshop, what is the total revenue generated from their purchases of *other* Adobe products (i.e., everything except Photoshop)? List the total revenue for each of these customers."**

---

### 2. Table Schema

The query references a single table, `adobe_transactions`. A plausible schema for this table would be:

```sql
-- Table: adobe_transactions
-- Stores a record for every product purchase made by a customer.
CREATE TABLE adobe_transactions (
    transaction_id   INT PRIMARY KEY,
    customer_id      INT NOT NULL,           -- The ID of the customer
    product          VARCHAR(100) NOT NULL,  -- The name of the product purchased, e.g., 'Photoshop', 'Acrobat'
    revenue          DECIMAL(10, 2) NOT NULL,-- The revenue from this transaction
    transaction_date DATE
);

-- An index on customer_id and product would improve performance for this query.
CREATE INDEX idx_adobe_customer_product ON adobe_transactions (customer_id, product);
```

---

### 3. Structured SQL Query (Method 1: Subquery with `IN`)

This is your original query, which is a clear and direct way to express the logic.

```sql
SELECT
    customer_id,
    SUM(revenue) AS revenue
FROM
    adobe_transactions
WHERE
    product != 'Photoshop'
    AND customer_id IN (
        SELECT DISTINCT
            customer_id
        FROM
            adobe_transactions
        WHERE
            product = 'Photoshop'
    )
GROUP BY
    customer_id;
```

---

### 4. Explanation of the Query

This query works by first identifying the target customers with a subquery and then aggregating their relevant transactions in the main query.

1.  **The Subquery: `(SELECT DISTINCT customer_id ...)`**
    *   The database executes this inner query first.
    *   It scans the `adobe_transactions` table and creates a distinct list of all `customer_id`s who have at least one transaction where the `product` is 'Photoshop'. This creates our "list of Photoshop customers."

2.  **The Main Query**:
    *   **`FROM adobe_transactions`**: The outer query begins its scan of the same table.
    *   **`WHERE customer_id IN (...)`**: This is the first filter. It checks if the `customer_id` for the current row exists in the "list of Photoshop customers" generated by the subquery.
    *   **`AND product != 'Photoshop'`**: This is the second filter. For the customers who passed the first check, it then keeps only the transaction rows that are *not* for Photoshop.
    *   The combination of these filters leaves us with all non-Photoshop transactions made by customers who have, at some point, bought Photoshop.
    *   **`GROUP BY customer_id`**: It then groups these remaining rows by customer.
    *   **`SELECT customer_id, SUM(revenue) AS revenue`**: Finally, for each customer group, it calculates the `SUM` of the `revenue`, giving the total revenue from their non-Photoshop purchases.

---

### 5. Another SQL Method (Method 2: Conditional Aggregation with `HAVING`)

An alternative and often more performant approach is to use conditional aggregation in a single query block, avoiding an explicit subquery.

```sql
SELECT
    customer_id,
    SUM(CASE WHEN product != 'Photoshop' THEN revenue ELSE 0 END) AS revenue
FROM
    adobe_transactions
GROUP BY
    customer_id
HAVING
    -- This condition ensures the customer has purchased Photoshop at least once
    COUNT(CASE WHEN product = 'Photoshop' THEN 1 END) > 0;
```

---

### 6. Explanation of the Alternative Query

This method processes all customers in a single pass, calculating the desired revenue and checking the condition simultaneously.

1.  **`FROM adobe_transactions`**: The query reads the table.
2.  **`GROUP BY customer_id`**: This is a crucial first step. It creates a summary group for **every single customer** in the table, regardless of what they bought.
3.  **`HAVING COUNT(CASE WHEN product = 'Photoshop' THEN 1 END) > 0`**: This clause filters the *groups*.
    *   For each customer's group, `COUNT(CASE ...)` counts how many of their transactions were for 'Photoshop'.
    *   The `HAVING ... > 0` condition keeps only the customer groups that have at least one Photoshop purchase. This effectively replaces the `IN (SELECT ...)` subquery.
4.  **`SELECT customer_id, SUM(CASE WHEN product != 'Photoshop' THEN revenue ELSE 0 END) AS revenue`**: This is executed on the groups that passed the `HAVING` filter.
    *   This is a **conditional sum**. It iterates through all transactions in the customer's group.
    *   `CASE WHEN product != 'Photoshop' THEN revenue ELSE 0 END`: If a transaction is not for Photoshop, its `revenue` is included in the sum. If it *is* for Photoshop, `0` is added, so it doesn't affect the total.
    *   This correctly calculates the total revenue from all non-Photoshop products for the target customers.

This conditional aggregation method can be more efficient as it typically requires only one scan over the table.